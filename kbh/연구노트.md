# Intro

**개발 과정 기록**

<br><br>



<br><br>

# 23-05-15

**추후에 리팩토링 과정**

* ExceptionHandlerExceptionResolver를 통해서 API 예외처리를 진행하겠다.

<br>

**"로그인" 관련해서 쿠키 세션 만료시간을 추가 및 ArgumentResolver 추가**

* AOP관련 해서는 웹의 경우 @Aspect 보다 URL을 활용하는 인터셉터가 더 좋으므로 이를 이용해서 "로그인 인증" 관련을 진행을 저번에 했고, 여기선 ArgumentResolover로 멤버 객체 바로 가져오게 추가한다.
* 세션 저장소에는 최소한의 데이터만 넣는게 중요하므로 Member객체가 아닌 Member id만을 담아두겠다.

<br>

**나머지 API들 CRUD 진행**

<br><br>

# 23-05-04

**로그인 처리 로직 - 세션 방식을 사용 (물론 전달을 해야해서 쿠키도 함께 사용)**

* 맨 처음에 로그인을 하면 서버에서 세션Id를 담은 쿠키를 클라에 응답으로 준다.
* 클라는 요청시 항상 쿠키에 세션Id가 포함되어 전달하게되고,  
  서버는 전달받은 쿠키 정보로 "세션 저장소"를 조회해서 회원임을 인증한다 => 메모리에 "세션 저장소(톰캣이 관리)"

<br>

**클라이언트**

* **클라 상에서 로그인 기록 있으면 "소셜 로그인" 화면 없이 그냥 바로 => 서버로 uid 전송**
  * API 주소는 "로그인" 주소를 준다.
* **클라 상에서 로그인 기록 없으면 "소셜 로그인" 화면 및 로그인 시도 => 이때, 서버로 uid 전송**
  * API 주소는 "회원가입" 주소를 준다.
* **클라 상에서 로그아웃을 요청하는 경우는 쿠키 정보가 있어서 바로 API 호출 및 "소셜 로그인" 화면으로 이동.**
  * 물론, 클라 상의 로그인 기록도 꼭 지워줘야 나중에 "회원가입"으로 잘 넘어감.
  * API 주소는 "로그아웃" 주소를 준다.
* **마지막으로 앱의 종료 이벤트때 "로그아웃 API"  호출 코드를 작성한다.**
  * onDestroy같이 앱 종료 이벤트때 웹뷰에서 얻은 쿠키정보를 request에 담아서 로그아웃 API 호출해주기

<br>

**서버**

* **로그인 API => 받은 uid로 회원판단 시도!! ("회원 저장소"에서 확인!!)**

  - **회원 일시**

    * UUID로 세션Id를 생성해서 "회원 저장소"에서 받은 회원정보(=memberA)와 함께 "세션 저장소"에 기록

    * 세션Id를 응답 쿠키로 전달

    - **회원 아닐시** 
      - 회원이 아니라고 클라에게 전송 (클라는 위 <클라>파트의 2번 카테고리를 행하면 됨)


* **회원가입 API => 받은 uid로 회원판단 시도!! ("회원 저장소"에서 확인!!)**

  - **첫 가입 회원**

    * uid, 기타정보 등등을 "회원 저장소"에 기록하고, UUID로 세션Id를 생성해서 회원정보(=memberA)와 함께 "세션 저장소"에 기록

    * 세션Id를 응답 쿠키로 전달

    - **이미 가입한 중복 회원**
      - 이미 회원이라고 클라에게 전송 (클라는 위 <클라>파트의 1번 카테고리를 행하면 됨)


* **로그아웃 API**
  - 쿠키 정보에 세션Id를 활용해서 해당 세션을 "세션 저장소"에서 제거

<br>

**기대 효과**

* **로그인 할때 이점 => "소셜 로그인"을 사용한 이점**
  * "소셜 로그인"을 통해서 회원 id,pw 등등 개인정보는 해당 "소셜 커뮤니티"와 주고 받기 때문에 개인정보 털릴 위험이 적어짐. 
  * "소셜 로그인"을 통해서 얻은 uid 값 또한 회원 id,pw 와는 관계없는 값을 주기 때문에 uid만을 우리 "서버"에 줘서 회원가입을 하면 개인정보 털릴 걱정이 없음.(즉, pw털릴 위험이 없음)
    * "uid가 털린것 vs id,pw 털린것" 을 비교해봐도 uid가 훨씬 안정적

* **로그인 이후의 이점 => "세션 방식"을 사용한 이점**
  * "회원 저장소" 와 "세션 저장소"를 함께 운영함으로써 회원 정보와는 전혀 관련없는 세션Id값(UUID)을 쿠키에 담아서 클라와 통신을 하기 때문에 개인정보 털릴 걱정이 없음.
  * 만료시간을 설정할 수 있기 때문에 쿠키가 탈취당해도 시간이 지나면 사용못하게 할 수 있다.
  * 세션Id를 서버에서 관리하므로 해킹이 의심된다면?? 서버에서 해당 세션을 강제로 제거할 수 있다.

<br>

**기타**

* **만료시간**
  * 보통은 그냥 만료시간=30분 정했으면 30분 뒤에 세션이 제거되지만,  
    스프링의 `HttpSession`은 클라->서버 요청의 제일 최신 시간을 이용해서 그시간 + 만료시간 을 계산해서 세션을 제거해준다.
  * 우리는 만료시간을 어떤 방식을 체택 해야할까??  
    웹의 경우 클라에서 웹을 종료했다고해서 알 수 있는 방법이 없다. 다른 방법이 있다고는 하는데, 잘 모르겠다.
  * 하지만 앱의 경우 안드로이드를 예로들자면 앱 종료때 onDestroy() 이벤트가 발생한다.  
    **따라서 앱의 종료 이벤트때 서버에 세션Id를 제거해주는 "로그아웃 API"  호출 코드를 작성한다.**
* **세션 체크하는 코드는 우리 앱에서는 모든 로직에서 다 필요하다.**
  * **따라서 "공통 관심사"로 두고 해결**해야하는데, 스프링의 AOP로도 해결이 가능하지만  
    "서블릿 필터 or 스프링 인터셉터"를 사용하는것을 추천한다.   
  * 왜냐하면 웹과 관련된 공통 관심사는 HTTP의 정보들도 필요한데, 이 정보도 "서블릿 필터 or 스프링 인터셉터"는 "HttpServletRequest"로 제공하기 때문이다.
  * 결론 : "스프링 인터셉터"가 더 편리,정교,다양한기능 을 제공해서 이 방식을 이용  
    * 사용법은 "HandlerInterceptor" 인터페이스를 구현하면 된다.
    * 동작 흐름 : WAS->필터->서블릿(Dispatcher Servlet)->스프링 인터셉터->컨트롤러
      * 따라서 컨트롤러 전에 로그인 인증해서 인증여부에따라 컨트롤러를 호출하거나 안하면 된다.
* **세션Id를 통해서 "세션 저장소"에 기록된 Member 정보를 가져와서 각종 DB들을 접근할 수 있다.**
  * **""세션Id를 통해서 "세션 저장소"에 기록된 Member 정보를 가져와""** 이부분이 코드가 많이 겹칠듯 한데, 이는 추후에 AOP로 해결을 하던지 하도록 하자.
  * 또는 인터셉터 반환때 Member까지 반환하게끔 해결하는건 보안에 취약할 수 있다고 하니까 Spring Security와 같은 보안 프레임워크를 사용하여, 사용자 인증과 권한 부여를 처리하고, 컨트롤러에서는 SecurityContextHolder를 통해 인증된 사용자 정보를 가져오는 방법도 존재한다는걸 인지.

<br><br>

# 23-05-03

**네이밍**

- **Database**
  - 테이블명 형식으로 `ORDER 또는 order` 사용 **=> 대문자 or 소문자**
  - 컬럼명 형식으로 `order_id` 사용 **=> 스네이크 케이스**
- **JPA -> ORM(객체 관계 매핑)**
  - 엔티티명 형식으로 `OrderItem` 사용 **=> 파스칼 케이스**
  - 필드명 형식으로 `orderId` 사용 **=> 카멜 케이스**  
    - **스프링 부트는 자동으로 필드명을 `orderId -> order_id` 로 컬럼명 찾아서 매핑**
      - 흠.. 이렇게 배웠었는데 정확히는 테이블 컬럼이 `ORDER_ID` 로 생성 되는 중이다.
      - 아마도 맨 마지막에 대문자로 바뀌는듯 하다?
    - **스프링 부트는 자동으로 엔티티명을 `OrderItem -> ORDERITEM` 로 테이블명 찾아서 매핑**
      - 이것도 `orderitem` 으로 매핑하고 맨 마지막에 대문자로 바뀌는건가 싶다.

```java
@Getter @Setter
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id; // DB PK
    @Column(nullable = false) // Not Null
    private String uid; // Entity ID => 대체키

    private String nickname;

    @OneToMany(mappedBy = "member") // 양방향
    private List<Lists> lists = new ArrayList<>(); // 컬렉션은 필드에서 바로 초기화
```

* Member엔티티명이지만 MEMBER로 테이블 매핑 
* id는 id와 매핑되기 때문에 직접 "member_id"와 매핑 => 결국 컬럼명은 MEMBER_ID로 생성

**엔티티구현 -> 레퍼지토리 -> 서비스 -> 컨트롤러 구현 순서로 진행.**

엔티티 구현에 많은 비중을 쌓기 위해 여러가지 메서드들도 추가할 예정.

* 연관관계 편의 메서드 등등 => 양방향때 활용하면 좋을 듯 하다.

또한 구현 때 TDD 작성이 매우 중요하므로 엔티티가 아니여도,

**레퍼지토리와 서비스 단계들은 되도록이면 TDD 작성을 하자.**

**개발과정 정리**

* 요구사항 분석(대략적 기능)
* 기능 목록(상세한 기능)
* 설계 시작
  * 도메인 모델 분석(간략히)
  * 테이블 설계(DB)
  * 엔티티 설계(JPA)
* 코드 구현 (각 파트별 TDD도 함께)
  * 도메인 구현 -> 엔티티를 의미하며, 모든 계층에서 사용
  * 레퍼지토리 구현 -> DB와 상호작용
  * 서비스 구현 -> 비지니스 로직 & 트랜잭션
    * `도메인 모델 패턴` : 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 방식
    * `트랜잭션 스크립트 패턴` : 엔티티에는 비지니스 로직이 거의 없고 서비스 계층이 담당하는 방식
    * **참고로 `도메인 모델 패턴` 방식으로 진행 중**

  * 컨트롤러 구현 -> 웹 계층과 상호작용 (API 포함)

<br><br>

# 23-04-27

![image](https://user-images.githubusercontent.com/80165014/236442807-9c183cd9-424f-482e-b1c1-364f0e3825ab.png)

**엔티티 설계 과정**

•최대한 객체지향적으로 설계(테이즐 지향이 아닌)

•엔티티 설계대로 코드에 그대로 적용 됨

•따라서 member_id : Long 같은 필드명을 member : Member 형태로 객체 참조 형식으로 변경

•중요한 “연결 관계“

•기본적으로 “다대일”에서 “다“ 외래키를 가지며, 외래키를 가진 쪽이 주인, “일대일”의 경우 외래키를 아무나 가져도 되고 주인도 아무나 가능

•따라서 초기엔 주인을 중심으로 “단방향” 연결 관계 지향

•이후에 “양방향“ 설정에는 테이블 구조를 바꿀 필요없이 코드로 변경 가능하기 때문

•참고로 “일대일＂의 경우 “주 테이블 외래키 단방향“ 과 “대상 테이블 외래키 양방향“ 이 2가지의 연결관계가 존재하며 각각 장단점이 있어서 적절히 판단

<br><br>

# 23-04-14

**DB 구조 설계**

•사용자 ITEM에 “착용여부 상태” 컬럼 추가

•컬럼명 이름들 스프링 규칙에 맞게 수정

•일정 테이블 -> list_일정 테이블도 하나 추가

•“다대다“ 관계이므로 잘 풀어내야함.

•일정 테이블에 “타이머 상태정보” 를 위해 “상태” 테이블 추가

•그냥 일정인지 타이머 인지 구별 위해

•타이머 테이블 추가 및 “상태정보” 컬럼 추가(ENUM타입)

•**열품타** **처럼** : 허용앱 상태, 최대집중 상태 로 구별

•최대집중 상태 4시간? 이상시 보상X(제약조건 추가)

•허용앱 시간, 최대집중 시간, 총 누적시간 3개를 보여줌.

•시간 정보는 start, end 로 기록

•누적시간 계산은 전체 end – start => (허용, 최대집중 전부 포함)

**DB 구조 설계 (리스트_일정 테이블)**

•일정 테이블 -> list_일정 테이블도 하나 추가

•“다대다“ 관계

•하루 단위로 list_일정 테이블을 update할 것이기 때문

•“다대다” 관계는 중간에 테이블 하나 넣어서 잘 풀어내야 함.

•“다대다” 관계의 문제는 양방향으로 “무한 호출＂이 발생

•“ 하루_일정(=리스트) <-> 중간 연결(=리스트_일정) <-> 일정 “ 테이블 구조

•하루_일정 테이블과 중간연결 테이블에 양방향 관계 필요

•양방향 관계 없어도 구현가능하지만, 양방향 관계로 보기쉽게 구현하는것이 좋다

•중간 연결에서 일정 테이블은 단방향 관계

•“일정“ 에서 “하루_일정“ 으로 넘어갈 필요는 없기 때문

•참고 네이밍 규칙

•스프링 부트는 자동으로 ‘orderId -> order_id’ 로 컬럼명 찾아서 매핑

**DB 구조 설계 모습**

![image](https://user-images.githubusercontent.com/80165014/236442628-f00ad898-1bb2-427a-88b4-b4c0738f0b5b.png)

**보상관련**

•일정 완료에 따른 보상 관련해서는 재원이형 의견 추천

•타이머 사용시

•90% 미만?? 일반 보상

•90% 이상?? 큰 보상

•타이머 미사용시

•일반 보상

<br><br>

# 23-04-11

**DB 구조 설계**

•Erd cloud 사용(협업) 

•플래너 부분 DB 구조 자료조사후 개선할 예정

![image](https://user-images.githubusercontent.com/80165014/236442050-54f5a318-e92e-4051-a3c5-8ec846519330.png)

<br><br>

# 23-04-10

**DB 구조 설계**

•로그인 기능

•소셜 로그인 API 활용 + 한번 로그인하면 계속 자동 로그인

•uid 를 db에 기록해서 멤버 로그인!! (즉, 로그인을 복잡한 로직으로 할 필요가 없는 프로젝트이다.)

•기존 회원가입, 로그인 로직은 복잡하다. 참고 링크 참고

•https://rastalion.me/%ED%9A%8C%EC%9B%90-%EA%B0%80%EC%9E%85-%EB%B0%8F-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%84%A4%EA%B3%84/
