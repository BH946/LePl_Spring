# Intro

**개발 과정 기록**

참고) 인증체크 테스트할때 서버메모리에 쿠키를 저장하기 때문에 "로그아웃" 해줘야 함

<br><br>

## 23-10-31

**할일**

* 기능추가 - 상점,아이템 ( +캐시 ) -> DB설계까지.. 완.

  * 캐릭터에 화폐필드 추가

  * 캐릭터아이템에 아이템ID를 외래키로

  * 아이템 테이블 추가!
  * **나머지 API 구현은 유진님이 하고 계시는듯!**
* 경험치 리팩토링 -> **굿(유진님 개발!)**
* ++++test: 테스트코드 컨트롤러(MOCK)
  * 기존 테스트코드부터!! 새로!! 다시! 최대한 Assert로!
    * DOMAIN 먼저
      * character 완료(아이템구현후 캐릭터는 추가로!).
      * member 
* ++++refactor:
  * 전체적으로... 특히 Setter는 다 지우자.

* 모니터링 + 테스트 툴(공부)

<br><br>

## 23-10-17~24

**최적화**

* 브라우저 캐시 : 3d에셋 서버에 저장 후 스프링에 캐시 사용 -> 이 url을 threejs에 넘겨줘서 사용
  * 정적파일 캐싱 한줄로 끝내기.
* 서버 캐시(ex:@Cacheable, @Cacheput)
  * 팔로우(공통), 일정(앱단에서 기록), 캐릭터(상점,??)
* 쿼리튜닝(+코드 리팩토링)
  * **읽기전용쿼리힌트(레퍼지토리), 읽기전용트랜잭션사용(서비스)**
* 상점 테이블이나 아이템 테이블...!! 추가
  * !!@!@!@!@!@!@!@!@!@!@!@!!!
  * **테스트코드 컨트롤러도 나중에 작성 ㄱㄱ**
* 모니터링(인프런), 로드밸런싱([참고1](https://velog.io/@korea3611/Spring-Boot-Spring-Cloud-Gateway-Load-Balancer-MSA5), [참고2](https://kimyhcj.tistory.com/entry/Spring-Cloud-%EC%8B%9C%EB%A6%AC%EC%A6%88-5-Loadbalancer-feat-Ribbon)) 등등
  * 로드밸런싱은 방법이 다양함. 그냥 쿠버네티스로 배포 다 관리하고 싶긴함. 아니면 nginx 설치해서 로드밸런싱 한다던지.
    * 쿠버네티스?? 클라우드환경이라 비용생각해야함.
    * nginx?? 로컬에 설치해야하는데 그렇게 하기는 싫음.

  * 다만, 그건 최종 배포할때 결정하면 되는 문제라고 생각해서 그냥 본인 로컬에서 테스트 해볼수 있는 방안으로 생각을 돌림.
    * Eureka 란것을 사용하면 되는듯 하다. 위에 로드밸런싱 참고1,2 사이트함께 참고할것
    * https://cjw-awdsd.tistory.com/52

<br>

**할일**

0. AOP로 시간측정 코드 추가(최종 때 모니터링으로!!)  
   +쿼리 join조차 안쓴 코드로 바꾸기(Lists레포만 해당->findAllWithMemberTask,findByDateWithMemberTask !!)  
   +꼭 따로 복제하든 커밋으로 남겨두든하자  
   +추후에 모니터링때 비교위해서!
   * **OK**
1. 각 기능별 쿼리수, 시간 정리(적당히 캡쳐도)
   * 일정 조회(all, date) 부분
     * all(해당멤버의 모든 일정)
       * 일정 3개 조회 시간(all) : 46ms
       * 일정 3개 조회 쿼리(all) : 5개
     * date(해당멤버의 지정한 날짜범위 일정)
       * 하루 일정 2개 조회 시간(date) : 27ms
       * 하루 일정 2개 조회 쿼리(date) : 4개
   * 경험치 부분(리팩토링 필수)
     * expTask(일정 완료시 경험치)
       * Task(여러개가능) 1개 완료 시간 : 45ms
       * Task(여러개가능) 1개 완료 쿼리 : 14개..
     * expTimer(타이머 완료시 경험치)
       * Timer(1개만) 1개 완료 시간 : 48ms
       * Timer(1개만) 1개 완료 쿼리 : 8개..
   * 팔로우 부분(조회)
     * 시간 - 14ms
     * 쿼리 - 2개
   * 멤버 조회
     * pass
   * **OK(쿼리많은이유는 LAZY라서 어쩔수없음)**
2. 쿼리튜닝,코드리팩토링작성 한후의 쿼리수 정리    
   +인터셉터 추가수정 - 로그인때 멤버 조회하는겸 캐릭터ID도 같이 조회해두는게 좋을듯  
   +서버캐시도 바로 진행후 테스트 -> "팔로우"만
   * 캐릭터ID, 팔로우 서버캐시
     * 캐릭터 조회를 서버캐시로 기록해두는걸로 하겠음 - resolveArgument에서 따로 DB조회 하는건 굉장히 쿼리 낭비인것 같고, 캐릭터는 회원ID 만큼이나 많이 쓰이게 되기 때문
       * 참고로 멤버ID 는 이미 세션 메모리 사용중
       * **알림, 팔로우 부분에 findCharacterWithMember(캐시) 로 적용!**
     * 팔로우 캐시?
       * 팔로우 추가에 회원가입처럼 **"중복검증 로직 추가"**
       * **전체 멤버 조회 로직 작성후(페이징필수) 캐시 적용**
         * 팔로워순, 랜덤순 이런건 일단 프론트에서 할수도있으니 디테일한건 패스
   * 일정 조회(all, date) 부분
     * all(해당멤버의 모든 일정)
       * 일정 3개 조회 시간(all) : 30ms
       * 일정 3개 조회 쿼리(all) : 1개
     * date(해당멤버의 지정한 날짜범위 일정)
       * 하루 일정 2개 조회 시간(date) : 9ms
       * 하루 일정 2개 조회 쿼리(date) : 1개
   * 경험치 부분(리팩토링 필수) -> 나중에.... 수정..
     * expTask(일정 완료시 경험치)
       * Task(여러개가능) 1개 완료 시간 : 
       * Task(여러개가능) 1개 완료 쿼리 : 
     * expTimer(타이머 완료시 경험치)
       * Timer(1개만) 1개 완료 시간 : 
       * Timer(1개만) 1개 완료 쿼리 : 
   * 팔로우 부분(조회)
     * 시간 - 3ms
     * 쿼리 - 1개(캐시 캐릭)
   * 멤버 조회
     * 시간 - 44ms => 캐시? => 1ms (쿼리0개)
     * 쿼리 - 1개(join fetch)
3. 브라우저 캐시 - 일단 img!!  
   => 이건 three js 돌려서 브라우저에 저장잘되는지 테스트필수  
   => 꼭 캐시전 img로딩 시간과 캐시후 img로딩 시간기록  
   => 이때 3d에셋 예전꺼 받아서 그 이미지와 새로 경랑화된거 구매한 이미지 둘다 테스트 기록!!  
   * 웹 브라우저에서 같은 탭에서 새로고침이나 url요청시 캐시 무시되기도 한다고해서
   * **새로운 탭으로 계속 테스트**하자
   * 되는것같으면 **반드시 three js 로 확인!!**
     * **CORS 해결**
     * **OK**
4. 서버 캐시 - 팔로우(공통), 상점(이건 말만하자. 최종때개밝.)  
   => 이것도 꼭 적용전과 후 속도차이 !!!!! 기록!!  
   => 쿼리가 안날라가서 굉장히 빠를거임.
   * 위에서 이미 적용했음!. **OK**

<br>

**경험치부분 꼭 리팩토링 해야함.**

<br><br>

## 23-10-13

**타이머 구현완료**

* 클라한테는 밀리세컨 단위로 "사용시간" 보내달라 하기
* 서버 DB는 Long 타입으로 "현재시간, 타이머총사용시간, 잔여시간" 구성
  * 단, 일정조회 관련 컨트롤러로 클라한테 반환할때는 "시:분:초" 형태로 바꿔서 반환
  * 구현쉽게 String으로 반환

<br>

**최적화 적용연습**

<br><br>

## 23-10-12

**경험치 체계 확립**

* `=INT((A2-1)^1.2)+10` 이걸로 일단 진행 및 상한선 레벨 100 지정
  * 1년간 시즌제를 통해서 만렙이 100정도까지 경험치 얻을수 있음.
* 물론 추후 테스트를 진행하면서 바뀔가능성도 높음

**타이머 구조 정리 -> "사용시간" 밀리세컨 단위로 달라할것**

* 타이머 테이블 삭제해야 할 듯
  * 여기있던 "집중,허용"상태는 따로 앱사용시 타이머 일시정지로 만들어버리는걸로 **질문방지**
* 클라이언트에서 "사용시간"을 전송
  * 일정추가{시작, 끝, 내용}
    * 일반 일정 -> 체크표시로 완료 전송(클라에서)
      * expUpdate 사용!
    * 타이머 일정 -> 체크표시 사용X. 무조건 종료때!
      * if 타이머상태OFF : 일정상태{타이머상태ON}, 일정{잔여시간}, 리스트{총사용시간}, 리스트{현재시간} 기록
      * else : 일정{잔여시간}, 리스트{총사용시간}, 리스트{현재시간} -> **시간계산**
        * if,else 타이밍은 타이머 종료때로 볼 수 있다.
        * 단, if면 초기 타이머 생성단계. 즉 초기화 단계
    * 시간계산과정
      * if -> 초기화 과정으로 보면 됨
        * 타이머상태 = ON
        * (TASK)잔여시간 = (끝시간 - 시작시간) - "사용시간"
        * (LISTS)타이머총사용시간 += "사용시간"
        * (LISTS)현재시간 += "사용시간"
          * **시간계산**
      * else
        * 잔여시간 -= "사용시간"
        * 타이머총사용시간 += "사용시간"
        * 현재시간 += "사용시간"
          * **시간계산**
      * **시간계산 -> 시간만 경험치 업데이트에 사용**
        * if 현재시간/시간 == 0 : pass
        * else
          * 경험치시간=현재시간/시간
          * 현재시간=현재시간%시간
          * **expUpdate(경험치시간)**
* **일정완료 컨트롤러에서** 타이머상태 조건문에 따라
  * 일반일정완료, 타이머일정완료 구현
  * **사용시간(클라) : 밀리세컨단위로 클라에게서 받기!**
  * **현재시간(계산용), 잔여시간, 타이머총사용시간 : 밀리세컨단위로 기록하기! -> 즉.. 전부다 밀리세컨!**
    * 왜냐하면 날짜로는 기록할수가 없음. 시간타입으로도 24시간을 넘어가서 기록이안됨
    * **애초에 Long으로 DB에 기록하고, 클라에 줄때 String으로 {시:분:초}로 보내**줘야할듯 ㅇㅇ

<br><br>

## 23-09-27 ~

**경험치 수식 재정립**

* 기존공식에 레벨당 필요경험치를 더욱 낮추자.
  * 초반, 중반, 후반에 레벨난이도는 갈수록 어려워지는게 맞을까?
    * **장점 : 레벨이 높을수록 확실히 강해지는 효과**
    * 단점 : 경험치 보상은 일정해서 레벨업이 힘듦. 뽑기도 자주 못하게됨.
    
  * 아니면 일정한게 맞을까?
    * **장점 : 레벨업이 매우 수월(쉬움). 이로인해 잦은 뽑기**
    * 단점 : 레벨업이 너무쉬워서 레벨의 의미가 약해지므로 동기부여가 제한
    
  * **결론1 : 두 장점을 가져가게끔 중간지점을 찾는다면?**
    
    * 레벨업을 쉽게하기 위해 - 경험치 수식을 수정해서(계수를 낮춘다던지) 레벨업을 쉽게끔 하자
    
      * 흠... 플래너 관련해서는 자료가 안보임 ㅠ
    
      * 임의로 계수 조절한 공식은 : INT((레벨-1)^1.2)+10
    
      * | 레벨 | 필요경험치 | 누적경험치 |
        | ---- | ---------- | ---------- |
        | 1    | 10         | 10         |
        | 2    | 11         | 11         |
        | 3    | 12         | 12         |
        | 4    | 13         | 13         |
        | 5    | 15         | 15         |
        | 6    | 16         | 16         |
        | 7    | 18         | 18         |
        | 8    | 20         | 20         |
        | 9    | 22         | 22         |
        | 10   | 23         | 23         |
    
    * 경험치 흭득유도를 위해 - 레벨업에 뽑기만 주는것이 아닌 레벨에 따른 경험치를 얻을때 "화폐"로도 챙겨주자
      * 추가로 특정레벨(5,10,15...)에 추가보상(방 넓히기, 선물지급 등등)을 주자
    
  * **결론2 : 중간지점이 별로라면 일정한것도 좋다고 생각**
    
    * 경험치 보상을 하루 제한을 걸어놨으므로 20정도로 일정하게 하면 되지않을까싶음
    * 대신 레벨의 의미가 약해지므로 이를 방지할 방안이 필요할듯
    
  * **결론3 : 한달마다 레벨을 초기화 하는건?**
  
    * 매달 초기화를 하기 때문에 기존 경험치 수식 or 계수를 좀 더 낮춘 수식 사용하면 될듯?
    * 계획 수행을 남들보다 늦게 시작해도 다음달에 레벨경쟁에 참여할 수 있다.
    * 매달 초기화 함으로써 매달 새롭게 플랜을 시작할 수 있다 -> 게임보단 좀 더 플랜에 비중
      * 계획이 1년 단위보다는 한달 단위로 수행하는게 더 플랜수행에 효과적이라 생각
    * 단, 레벨 초기화일 뿐 얻은 화페 및 보상아이템은 그대로 간직

<br>

**로우폴리 에셋찾아보기**

* 가구 위주로
  * [유료](https://assetstore.unity.com/packages/3d/props/furniture/low-poly-furniture-156774?locale=ko-KR)
  * [유료-예시로 쓰기 좋아보임](https://assetstore.unity.com/packages/3d/props/interior/low-poly-furniture-assets-221471)
  * [무료](https://assetstore.unity.com/packages/3d/props/furniture/low-poly-simple-furniture-free-240197?locale=ko-KR)
  * [무료](https://assetstore.unity.com/packages/3d/props/furniture/3d-dungeon-lowpoly-pack-231265)

<br>

**타이머 기능 및 컨트롤러**

* 타이머의 경험치 계산은 "집중, 허용" 상태를 제외하고는 구현된 상황
* 타이머 컨트롤러만 구현하면 되는데 구조가 Task에 꼭 묶여있는거 생각하고 구현
  * 생각해보니 이미 경험치 계산에 사용한 타이머인지 구분이 필요해서 필드 하나 추가해야할듯


<br>

**최적화 위주로 진행**

* 쿼리튜닝
  * 코드 계속 리팩토링을 거쳐서 쿼리수 줄여야 할듯
  * 다만 기능부터 다 개발이 완벽히 끝난게 확인되면 그때부터 진행해야할듯

* 캐시

  * https://hongong.hanbit.co.kr/%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%ED%86%A0%ED%81%B0-%EC%BA%90%EC%8B%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-cdn/  
    https://tbread-development.tistory.com/m/25  
    https://mygumi.tistory.com/275

  * https://rumor1993.tistory.com/86
    https://blog.lael.be/post/7605
    https://hudi.blog/spring-http-caching/
    https://wildeveloperetrain.tistory.com/119

    https://kim-gpt.tistory.com/entry/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EB%8B%A8-%EC%BA%90%EC%8B%9C-Client-side-Caching
    https://kim-gpt.tistory.com/entry/%EC%84%9C%EB%B2%84-%EB%8B%A8-%EC%BA%90%EC%8B%9C-Server-side-Caching

    (클ㄹ라!)브라우저 캐시 종류 - 디스크캐시, 메모리캐시
    (섯버!)서버 캐시 종류 - CDN, 등등...

    아마 아래는 전부 서버가 부담하는 서버단캐시 일거다.
    (1)정적이미지용 캐시 - .setCacheControl(cacheControl); 써서 메모리에 캐시해서 속도를 올리자(정적파일은 우리가 그냥 제공해주자URL)
    -> CDN-AWS S3? 로 구성해서 이미지 얻는게 속도가 더 빠르다고 하긴하는데 이건 고민,,
    -> 또한 Redis 같이 캐시서버 구축방법도 좋아보임(아마 위에서 설명한 캐시는 메모리에 바로 쓰는거? 잘 모르겠음 차이는.)
    
    ​	https://zangzangs.tistory.com/72
    
    (2)@Cachable - 나머지 캐시할것들 캐시ㄱㄱ
    
  * CDN을 사용하는게 굉장히 많은 속도 향상을 얻을듯 하다.(3d 이미지를 사용하다보니 이미지쪽 캐싱이 굉장히 중요하다고 생각)
  
* 모니터링

  * 이부분도 기능개발은 다 된것이 확인되면 진행해줘야 할듯하다.
  * 강의 본거 따라서 진행해보자.

* 로드밸런싱

  * [개념](https://velog.io/@alswn9938/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1), [개념](https://www.nowwatersblog.com/backend/serverLoad/serverDistribution)
  * [실습](https://velog.io/@msung99/Nginx-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-%ED%99%98%EA%B2%BD%EC%9D%84-%EA%B5%AC%EC%B6%95%ED%95%B4-%ED%8A%B8%EB%9E%98%ED%94%BD-%EB%B6%84%EC%82%B0%EC%8B%9C%ED%82%A4%EA%B8%B0-feat.-%EB%AC%B4%EC%A4%91%EB%8B%A8%EB%B0%B0%ED%8F%AC_)
  * [로드밸런싱테스트](https://velog.io/@znftm97/Nginx-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC)
    * [DevOps 강의](https://velog.io/@znftm97/series/Class101-foo-%EA%B0%95%EC%9D%98)

<br><br>

## 23-09-19~22

**캐릭터(친구기능) 목욜까지**

* 경험치량 수식 적용(임의로 아래 수식사용 - 확정은 아님)
  * 필요 경험치 수식 : (레벨-1)^2*1.5(계수)
  * 일정 경험치 보상량 : 1 or 1+T(Time)
  * 클라에서는 API요청 때 이전 레벨과 요청후 레벨이 다르면 "레벨업" 임펙트 발생시키면 될듯
  * **reqExp필드 추가 얘기하기!**
* **친구 테이블 -> 팔로우 테이블로 변경**
  * follow{follow_id, follower_id, following_id, 캐릭터id(fk)} - 팔로워들 id는 캐릭터id 사용
    * from - to 느낌
  * 알림은?? 알림 테이블을 따로 만들어두자
    * http://www.ciboard.co.kr/manual/tables/notification 참고 DB
    * **알림 테이블 물어보쟈!! -> OK OK**
* **"컨트롤러(API)" -> 할차례!!,,**
  * 캐릭터
    * 캐릭터 생성 API - 회원가입때...바로진행.. 따라서 "**회원가입 API**" 파트에서 해결?하자?
      * UUID와 닉넴 받을텐데 이때 "**경험치, 캐릭터 테이블**" 함께 생성
  * 경험치
    * 경험치량 조회 API - 누적, 현재, 레벨 전부 제공
    * 경험치 업데이트는 "**일정완료 API**" 추가해서 이곳에서 진행하자!
      * 경험치 제한까지 구현완료
      * 스케줄링으로 "일일경험치 제한" 매일 초기화 구현완료
  * 팔로우
    * 팔로우 생성 API
    * 팔로우 제거 API
    * 팔로잉 / 팔로워 조회 API - 팔로잉(해당캐릭터의 팔로잉), 팔로워(모든캐릭터의 팔로잉)
    * 팔로우시 상대방은 자신을 팔로우했는지 알려주는 API -> 이건그냥 PASS
      * 테이블 검색후 있으면 "맞팔로우 하기" 로 버튼명 변경하게끔
  * 알림 
    * 알림 생성 API - 팔로우 때 해야해서 **"팔로우 생성 API"**에 추가
    * 알림 조회 API
    * 알림제거는 따로 하지말고 읽음표시로 클라에서 해결하자
* **"화폐"는 상점만들때 추가 하겠음**
* **"일정완료" 종류**
  * 클라에서 일정들 체크 후 서버로 전송(List) -> OK
  * 클라에서 타이머 .... -> 타이머 구현방식 구글링 필요해보임.. -> 아직 X

<br>

주저리 주저리.. 회의내용들...

**경험치**

* 필요 경험치 수식 : (레벨-1)^2*1.5(계수)
* 일정소화 경험치 보상 : 1
* 타이머 경험치 보상 : 1+T(Time)
* 하루 최대 경험치 제한 : 24
  * 일정소화 최대 경험치 : 12
  * 타이머 최대 경험치 : 12
* 추후에 생각할 경험치
  * 타이머의 구체화 "집중, 허용시간"
  * 검증된 일정 소화의 경험치 - 예로 "러닝"

**기능개발 우선 - 캐릭터, 타이머, 상점**

**서버 성능 최적화**

* 모니터링
* 쿼리수 줄이기
* 캐시
* 로드밸런싱

## 23-09-17

아래 순서로 개발해나갈 예정,,, -> 먼저 **"캐릭터"**

개발
1. 캐릭터(친구,화폐,아이템, 경험치 등)
2. 타이머

리팩토링
1. 검증(Validation)
2. API 예외처리
3. AOP(공통 관심 해결사), 캐싱 등등
   * **애플리케이션의 성능을 개선**하기 위해 캐싱, 로드밸런싱 등을 적용할 예정

<br>

**[ERDCloud](https://www.erdcloud.com/d/qhJLFCiq5KpRSDN87) -> "화폐 제거"**

* 엔티티 -> "캐릭터" + 친구, 캐릭터아이템, 경험치
  * 친구 테이블명 friend로
    * id는 freind_id 로
  * 캐릭터의 레벨은 경험치 테이블로 옮기자 - 계산하기 더 쉽게
    * 임의로 경험치량 10으로 테스트.
  * **엔티티 - 테스트완료** -> 테스트코드 실행이 안되서 아래 두가지 수정으로 해결
    * 첫번째로 패키지명이 안바껴서 lepl로 전부 수정.
    * 다음으로 test패키지에 따로 application.yml 을 또 설정해놨었다. lepl로 수정.
* 레퍼지토리, 서비스 - 테스트 완료

<br>

**경험치량**

* 필요 경험치 = ((레벨 - 1) * 50 / 49) ^ 2.5 * 계수(=100만 테이블의 경우 10)
* 누적 경험치 = (기본 제공 수치 * 레벨^2) + 추가 제공 수치
* https://www.thisisgame.com/pad/tboard/?n=54281&board=22
* https://adelius.tistory.com/121
  * https://m.blog.naver.com/sirasaya/3032113

<br><br>

# 23-06-06

**리스트와 일정 "1:N" 관계로 전체적으로 수정**

**타이머를 제외하고 일정 관련한 조회, 수정, 삭제 등등 우선 개발**

* 조회 로직 쿼리 전송량 개선을 위해 **fetch join+distinct** 적절히 사용
* 조회 로직 null 문제 때문에 **lazy 강제 초기화** 적절히 사용

<br>

**Postman 의 기능을 좀 더 공부하여 API 명세서를 작성**

* 테스트 API 명세서 : https://documenter.getpostman.com/view/21970313/2s93mBwec5

<br>

**일정 완료의 경우 생각중인건??(지금은 안할생각)**

* 1분마다 @Scheduled 같이 스케줄링
  * 무엇을?? 전체 Task 조회로직을 실행해서 "종료시간"을 활용
  * `현재 서버시간 >= 종료시간` 이라면, 종료된(완료된) 일정이란것을 판단

<br><br>

# 23-05-31

**나머지 API들 CRUD 진행 및 엔티티에 편의 메서드들(비지니스, 생성 등등) 추가**

* 레퍼지토리, 서비스, 컨트롤러 작성
* TDD까지 함께 작성

<br>

**문제가 발생.. 리스트와 일정은 "다대다"관계가 아니였던것 같다.  
"다대다" 관계는 추후에 추가할 아이템 목록 테이블이 캐릭터와 "다대다" 관계로 해야한다.**

**따라서 리스트와 일정은 "1:N" 관계인 것 같고, 우선 이 관계를 DB에 추가로 그려놔야겠다...**

<br><br>

# 23-05-15

**추후에 리팩토링 과정**

* ExceptionHandlerExceptionResolver를 통해서 API 예외처리를 진행하겠다.

<br>

**"로그인" 관련해서 쿠키 세션 만료시간을 추가 및 ArgumentResolver 추가**

* AOP관련 해서는 웹의 경우 @Aspect 보다 URL을 활용하는 인터셉터가 더 좋으므로 이를 이용해서 "로그인 인증" 관련을 진행을 저번에 했고, 여기선 ArgumentResolover로 멤버 객체 바로 가져오게 추가한다.
* 세션 저장소에는 최소한의 데이터만 넣는게 중요하므로 Member객체가 아닌 Member id만을 담아두겠다.

<br>

**나머지 API들 CRUD 진행**

<br><br>

# 23-05-04

**로그인 처리 로직 - 세션 방식을 사용 (물론 전달을 해야해서 쿠키도 함께 사용)**

* 맨 처음에 로그인을 하면 서버에서 세션Id를 담은 쿠키를 클라에 응답으로 준다.
* 클라는 요청시 항상 쿠키에 세션Id가 포함되어 전달하게되고,  
  서버는 전달받은 쿠키 정보로 "세션 저장소"를 조회해서 회원임을 인증한다 => 메모리에 "세션 저장소(톰캣이 관리)"

<br>

**클라이언트**

* **클라 상에서 로그인 기록 있으면 "소셜 로그인" 화면 없이 그냥 바로 => 서버로 uid 전송**
  * API 주소는 "로그인" 주소를 준다.
* **클라 상에서 로그인 기록 없으면 "소셜 로그인" 화면 및 로그인 시도 => 이때, 서버로 uid 전송**
  * API 주소는 "회원가입" 주소를 준다.
* **클라 상에서 로그아웃을 요청하는 경우는 쿠키 정보가 있어서 바로 API 호출 및 "소셜 로그인" 화면으로 이동.**
  * 물론, 클라 상의 로그인 기록도 꼭 지워줘야 나중에 "회원가입"으로 잘 넘어감.
  * API 주소는 "로그아웃" 주소를 준다.
* **마지막으로 앱의 종료 이벤트때 "로그아웃 API"  호출 코드를 작성한다.**
  * onDestroy같이 앱 종료 이벤트때 웹뷰에서 얻은 쿠키정보를 request에 담아서 로그아웃 API 호출해주기

<br>

**서버**

* **로그인 API => 받은 uid로 회원판단 시도!! ("회원 저장소"에서 확인!!)**

  - **회원 일시**

    * UUID로 세션Id를 생성해서 "회원 저장소"에서 받은 회원정보(=memberA)와 함께 "세션 저장소"에 기록

    * 세션Id를 응답 쿠키로 전달

    - **회원 아닐시** 
      - 회원이 아니라고 클라에게 전송 (클라는 위 <클라>파트의 2번 카테고리를 행하면 됨)


* **회원가입 API => 받은 uid로 회원판단 시도!! ("회원 저장소"에서 확인!!)**

  - **첫 가입 회원**

    * uid, 기타정보 등등을 "회원 저장소"에 기록하고, UUID로 세션Id를 생성해서 회원정보(=memberA)와 함께 "세션 저장소"에 기록

    * 세션Id를 응답 쿠키로 전달

    - **이미 가입한 중복 회원**
      - 이미 회원이라고 클라에게 전송 (클라는 위 <클라>파트의 1번 카테고리를 행하면 됨)


* **로그아웃 API**
  - 쿠키 정보에 세션Id를 활용해서 해당 세션을 "세션 저장소"에서 제거

<br>

**기대 효과**

* **로그인 할때 이점 => "소셜 로그인"을 사용한 이점**
  * "소셜 로그인"을 통해서 회원 id,pw 등등 개인정보는 해당 "소셜 커뮤니티"와 주고 받기 때문에 개인정보 털릴 위험이 적어짐. 
  * "소셜 로그인"을 통해서 얻은 uid 값 또한 회원 id,pw 와는 관계없는 값을 주기 때문에 uid만을 우리 "서버"에 줘서 회원가입을 하면 개인정보 털릴 걱정이 없음.(즉, pw털릴 위험이 없음)
    * "uid가 털린것 vs id,pw 털린것" 을 비교해봐도 uid가 훨씬 안정적

* **로그인 이후의 이점 => "세션 방식"을 사용한 이점**
  * "회원 저장소" 와 "세션 저장소"를 함께 운영함으로써 회원 정보와는 전혀 관련없는 세션Id값(UUID)을 쿠키에 담아서 클라와 통신을 하기 때문에 개인정보 털릴 걱정이 없음.
  * 만료시간을 설정할 수 있기 때문에 쿠키가 탈취당해도 시간이 지나면 사용못하게 할 수 있다.
  * 세션Id를 서버에서 관리하므로 해킹이 의심된다면?? 서버에서 해당 세션을 강제로 제거할 수 있다.

<br>

**기타**

* **만료시간**
  * 보통은 그냥 만료시간=30분 정했으면 30분 뒤에 세션이 제거되지만,  
    스프링의 `HttpSession`은 클라->서버 요청의 제일 최신 시간을 이용해서 그시간 + 만료시간 을 계산해서 세션을 제거해준다.
  * 우리는 만료시간을 어떤 방식을 체택 해야할까??  
    웹의 경우 클라에서 웹을 종료했다고해서 알 수 있는 방법이 없다. 다른 방법이 있다고는 하는데, 잘 모르겠다.
  * 하지만 앱의 경우 안드로이드를 예로들자면 앱 종료때 onDestroy() 이벤트가 발생한다.  
    **따라서 앱의 종료 이벤트때 서버에 세션Id를 제거해주는 "로그아웃 API"  호출 코드를 작성한다.**
* **세션 체크하는 코드는 우리 앱에서는 모든 로직에서 다 필요하다.**
  * **따라서 "공통 관심사"로 두고 해결**해야하는데, 스프링의 AOP로도 해결이 가능하지만  
    "서블릿 필터 or 스프링 인터셉터"를 사용하는것을 추천한다.   
  * 왜냐하면 웹과 관련된 공통 관심사는 HTTP의 정보들도 필요한데, 이 정보도 "서블릿 필터 or 스프링 인터셉터"는 "HttpServletRequest"로 제공하기 때문이다.
  * 결론 : "스프링 인터셉터"가 더 편리,정교,다양한기능 을 제공해서 이 방식을 이용  
    * 사용법은 "HandlerInterceptor" 인터페이스를 구현하면 된다.
    * 동작 흐름 : WAS->필터->서블릿(Dispatcher Servlet)->스프링 인터셉터->컨트롤러
      * 따라서 컨트롤러 전에 로그인 인증해서 인증여부에따라 컨트롤러를 호출하거나 안하면 된다.
* **세션Id를 통해서 "세션 저장소"에 기록된 Member 정보를 가져와서 각종 DB들을 접근할 수 있다.**
  * **""세션Id를 통해서 "세션 저장소"에 기록된 Member 정보를 가져와""** 이부분이 코드가 많이 겹칠듯 한데, 이는 추후에 AOP로 해결을 하던지 하도록 하자.
  * 또는 인터셉터 반환때 Member까지 반환하게끔 해결하는건 보안에 취약할 수 있다고 하니까 Spring Security와 같은 보안 프레임워크를 사용하여, 사용자 인증과 권한 부여를 처리하고, 컨트롤러에서는 SecurityContextHolder를 통해 인증된 사용자 정보를 가져오는 방법도 존재한다는걸 인지.

<br>

**네이밍**

- **Database**
  - 테이블명 형식으로 `ORDER 또는 order` 사용 **=> 대문자 or 소문자**
  - 컬럼명 형식으로 `order_id` 사용 **=> 스네이크 케이스**
- **JPA -> ORM(객체 관계 매핑)**
  - 엔티티명 형식으로 `OrderItem` 사용 **=> 파스칼 케이스**
  - 필드명 형식으로 `orderId` 사용 **=> 카멜 케이스**  
    - **스프링 부트는 자동으로 필드명을 `orderId -> order_id` 로 컬럼명 찾아서 매핑**
      - 흠.. 이렇게 배웠었는데 정확히는 테이블 컬럼이 `ORDER_ID` 로 생성 되는 중이다.
      - 아마도 맨 마지막에 대문자로 바뀌는듯 하다?
    - **스프링 부트는 자동으로 엔티티명을 `OrderItem -> ORDERITEM` 로 테이블명 찾아서 매핑**
      - 이것도 `orderitem` 으로 매핑하고 맨 마지막에 대문자로 바뀌는건가 싶다.

```java
@Getter @Setter
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id; // DB PK
    @Column(nullable = false) // Not Null
    private String uid; // Entity ID => 대체키

    private String nickname;

    @OneToMany(mappedBy = "member") // 양방향
    private List<Lists> lists = new ArrayList<>(); // 컬렉션은 필드에서 바로 초기화
```

* Member엔티티명이지만 MEMBER로 테이블 매핑 
* id는 id와 매핑되기 때문에 직접 "member_id"와 매핑 => 결국 컬럼명은 MEMBER_ID로 생성

**엔티티구현 -> 레퍼지토리 -> 서비스 -> 컨트롤러 구현 순서로 진행.**

엔티티 구현에 많은 비중을 쌓기 위해 여러가지 메서드들도 추가할 예정.

* 연관관계 편의 메서드 등등 => 양방향때 활용하면 좋을 듯 하다.

또한 구현 때 TDD 작성이 매우 중요하므로 엔티티가 아니여도,

**레퍼지토리와 서비스 단계들은 되도록이면 TDD 작성을 하자.**

**개발과정 정리**

* 요구사항 분석(대략적 기능)
* 기능 목록(상세한 기능)
* 설계 시작
  * 도메인 모델 분석(간략히)
  * 테이블 설계(DB)
  * 엔티티 설계(JPA)
* 코드 구현 (각 파트별 TDD도 함께)
  * 도메인 구현 -> 엔티티를 의미하며, 모든 계층에서 사용
  * 레퍼지토리 구현 -> DB와 상호작용
  * 서비스 구현 -> 비지니스 로직 & 트랜잭션
    * `도메인 모델 패턴` : 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 방식
    * `트랜잭션 스크립트 패턴` : 엔티티에는 비지니스 로직이 거의 없고 서비스 계층이 담당하는 방식
    * **참고로 `도메인 모델 패턴` 방식으로 진행 중**

  * 컨트롤러 구현 -> 웹 계층과 상호작용 (API 포함)

<br><br>

# 23-04-27

![image](https://user-images.githubusercontent.com/80165014/236442807-9c183cd9-424f-482e-b1c1-364f0e3825ab.png)

**엔티티 설계 과정**

•최대한 객체지향적으로 설계(테이즐 지향이 아닌)

•엔티티 설계대로 코드에 그대로 적용 됨

•따라서 member_id : Long 같은 필드명을 member : Member 형태로 객체 참조 형식으로 변경

•중요한 “연결 관계“

•기본적으로 “다대일”에서 “다“ 외래키를 가지며, 외래키를 가진 쪽이 주인, “일대일”의 경우 외래키를 아무나 가져도 되고 주인도 아무나 가능

•따라서 초기엔 주인을 중심으로 “단방향” 연결 관계 지향

•이후에 “양방향“ 설정에는 테이블 구조를 바꿀 필요없이 코드로 변경 가능하기 때문

•참고로 “일대일＂의 경우 “주 테이블 외래키 단방향“ 과 “대상 테이블 외래키 양방향“ 이 2가지의 연결관계가 존재하며 각각 장단점이 있어서 적절히 판단

<br><br>

# 23-04-14

**DB 구조 설계**

•사용자 ITEM에 “착용여부 상태” 컬럼 추가

•컬럼명 이름들 스프링 규칙에 맞게 수정

•일정 테이블 -> list_일정 테이블도 하나 추가

•“다대다“ 관계이므로 잘 풀어내야함.

•일정 테이블에 “타이머 상태정보” 를 위해 “상태” 테이블 추가

•그냥 일정인지 타이머 인지 구별 위해

•타이머 테이블 추가 및 “상태정보” 컬럼 추가(ENUM타입)

•**열품타** **처럼** : 허용앱 상태, 최대집중 상태 로 구별

•최대집중 상태 4시간? 이상시 보상X(제약조건 추가)

•허용앱 시간, 최대집중 시간, 총 누적시간 3개를 보여줌.

•시간 정보는 start, end 로 기록

•누적시간 계산은 전체 end – start => (허용, 최대집중 전부 포함)

**DB 구조 설계 (리스트_일정 테이블)**

•일정 테이블 -> list_일정 테이블도 하나 추가

•“다대다“ 관계

•하루 단위로 list_일정 테이블을 update할 것이기 때문

•“다대다” 관계는 중간에 테이블 하나 넣어서 잘 풀어내야 함.

•“다대다” 관계의 문제는 양방향으로 “무한 호출＂이 발생

•“ 하루_일정(=리스트) <-> 중간 연결(=리스트_일정) <-> 일정 “ 테이블 구조

•하루_일정 테이블과 중간연결 테이블에 양방향 관계 필요

•양방향 관계 없어도 구현가능하지만, 양방향 관계로 보기쉽게 구현하는것이 좋다

•중간 연결에서 일정 테이블은 단방향 관계

•“일정“ 에서 “하루_일정“ 으로 넘어갈 필요는 없기 때문

•참고 네이밍 규칙

•스프링 부트는 자동으로 ‘orderId -> order_id’ 로 컬럼명 찾아서 매핑

**DB 구조 설계 모습**

![image](https://user-images.githubusercontent.com/80165014/236442628-f00ad898-1bb2-427a-88b4-b4c0738f0b5b.png)

**보상관련**

•일정 완료에 따른 보상 관련해서는 재원이형 의견 추천

•타이머 사용시

•90% 미만?? 일반 보상

•90% 이상?? 큰 보상

•타이머 미사용시

•일반 보상

<br><br>

# 23-04-11

**DB 구조 설계**

•Erd cloud 사용(협업) 

•플래너 부분 DB 구조 자료조사후 개선할 예정

![image](https://user-images.githubusercontent.com/80165014/236442050-54f5a318-e92e-4051-a3c5-8ec846519330.png)

<br>

**DB 구조 설계**

•로그인 기능

•소셜 로그인 API 활용 + 한번 로그인하면 계속 자동 로그인

•uid 를 db에 기록해서 멤버 로그인!! (즉, 로그인을 복잡한 로직으로 할 필요가 없는 프로젝트이다.)

•기존 회원가입, 로그인 로직은 복잡하다. 참고 링크 참고

•https://rastalion.me/%ED%9A%8C%EC%9B%90-%EA%B0%80%EC%9E%85-%EB%B0%8F-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%84%A4%EA%B3%84/
