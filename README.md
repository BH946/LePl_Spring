# Intro

**Intro(단축키,기본규칙) -> 개발과정 -> 기능들 로직(EX:로그인) -> 폴더구조 순서로 정리하겠다.**

**`개발과정`과 `기능들 로직` 은 개발을 진행하면서 계속 수정해야한다.**

<br>

**단축키**

* `Alt + Insert` : getter, setter, constructor 등 자동 생성
* `Ctrl + Alt + V` : 변수 선언부를 자동 작성
* `Ctrl + Alt + M` : 코드 리팩토링하기 쉽게끔 함수 자동 생성
* `Ctrl+T->extra method` : 코드 리팩토링하기 쉽게끔 드래그한 코드를 하나의 함수로 자동 생성
* `Alt + Shift + Down/Up` : 코드 한줄을 위, 아래 자리 이동 가능
* `Ctrl + D` : 코드 한줄 바로 아래에 복제
* `Ctrl + Alt + Shift` : 멀티 커서 가능
* `Shift + F6` : 변수명을 한번에 바꿀 때 사용
* `Alt + 1 ` : 왼쪽 프로젝트 폴더 구조 열기
* `Alt + F12` : 터미널 창 열기

<br>

**기본규칙(TIP)**

* **네이밍**
  - **Database**
    - 테이블명 형식으로 `ORDER 또는 order` 사용 **=> 대문자 or 소문자**
    - 컬럼명 형식으로 `order_id` 사용 **=> 스네이크 케이스**
    - 스프링에선 테이블 매핑 마지막에 전부 **"대문자"**로 바꿔주는것 같음
      - DB보니까 대문자로 전부 네이밍 되어있길래,,
  - **JPA -> ORM(객체 관계 매핑)**
    - 엔티티명 형식으로 `OrderItem` 사용 **=> 파스칼 케이스**
    - 필드명 형식으로 `orderId` 사용 **=> 카멜 케이스**  
      - **스프링 부트는 자동으로 필드명을 `orderId -> order_id` 로 컬럼명 찾아서 매핑**
      - **엔티티명은 `OrderItem -> ORDERITEM` 처럼 "대문자"로 바꿔주는건 여전하고, 다른 규칙은 없으므로 네이밍 작업 필요시 직접 테이블명과 매핑**
* **테이블과 엔티티 설계**
  * **N:N** 관계는 **1:N, N:1**로 풀고, 외래키는 **N**에 사용
  * **1:1**의 경우 **상황에 따라** 사용 - 보통은 `주 테이블에 외래키` 사용
    * 주 테이블 외래키 단방향 - 단점 : 값 없으면 외래 키에 null 허용
    * 대상 테이블에 외래키 양방향 - 단점 : 무조건 즉시로딩
  * **상속**의 경우 JOINED, SINGLE_TABLE 등등 전략 중에서 **JOINED 전략**을 많이 사용
    * SINGLE_TABLE : 부모, 자식테이블 전부 합쳐서 하나의 테이블로 구성
    * JOINED : 부모, 자식들 테이블 생성 및 Join으로 조회
  * 개발과정에선 **Getter, Setter**를 열어두고 나중에 리펙토링으로 **Setter** 들은 제거
    * 엔티티에서의 **비지니스 메서드** 구현은 **Setter** 제거 효과
    * **setter를 최대한 사용하지 않게끔 DTO 방식 권장**
  * 엔티티 설계 때 **연관관계는 단방향 우선 개발(테스트)** 후 양방향 관계 추가
  * **무조건 "지연 로딩" 개발** 및 `@XToOne` 은 기본이 **즉시 로딩**이므로 **지연로딩**으로 전부 변경
  * **ENUM** 데이터는 반드시 `@Enumerated(EnumType.STRING)` 로 옵션 지정 필수
  * **컬렉션(List같은것들)은 필드에서 바로 초기화가 효과적**
  * **의존성 주입(DI)은 스프링 필드 주입 대신에 생성자 주입을 사용**
    * 즉, `@RequiredArgsConstructor, final` 를 사용
  * 엔티티에서 `연관관계 편의 메서드, 비지니스 메서드, 생성 메서드, 조회 메서드` 등등 많은것을 개발하기를 권장
    * **`도메인 모델 패턴` 방식을 행하고 있기 때문**
* **엔티티 매핑**
  * **N:1,1:N** 의 경우 **"N:1 단(or양)방향"** 권장
  * **1:1** 의 경우 **"주 테이블 외래키 단방향"** 권장
  * **"양방향" 연관관계 코드로 작성시(개인적인 생각)** 연관관계 편의 메서드와 mappedBy 를 세트로 같이 작성
* **추가정보**
  * **"지연 로딩" 에서 "즉시 로딩"의 효과를 얻는법은 fetch join을 활용**
  * **동적 쿼리**는 **Querydsl** 을 권장
  * **API 응답 스펙에 맞추어 별도의 DTO를 반환 권장 (엔티티 노출 금지 목적)**
  * **setter를 최대한 사용하지 않게끔 DTO 방식 권장**
  * **JSON 반환시 꼭 마지막에 객체로 감싸서 반환**
  * **DTO와 DI(의존성 주입) 구분할 것**
  * **준영속 엔티티를 수정할 때 Merge방식보다는 Dirty Checking 방법 권장**

<br><br>

# 개발과정

* **요구사항 분석(대략적 기능)**
* **구체적인 요구사항 목록(상세한 기능)**
* **설계 시작**
  * 도메인 모델 분석(간략히)
  * 테이블 설계(DB)
  * 엔티티 설계(JPA)
  * **ERDCloud 툴을 사용한 설계 => 테이블, 엔티티 설계 없애고 이걸로 통일할까...??**
* **코드 구현 (각 파트별 TDD도 함께)**
  * 도메인 구현 -> 엔티티를 의미하며, 모든 계층에서 사용
  * 레퍼지토리 구현 -> DB와 상호작용
  * 서비스 구현 -> 비지니스 로직 & 트랜잭션
    * `도메인 모델 패턴` : 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 방식
    * `트랜잭션 스크립트 패턴` : 엔티티에는 비지니스 로직이 거의 없고 서비스 계층이 담당하는 방식
    * **참고로 `도메인 모델 패턴` 방식으로 진행 중**

  * 컨트롤러 구현 -> 웹 계층과 상호작용 (API 포함)

<br><br>

## 1. 요구사항 분석(진행중)

![image](https://user-images.githubusercontent.com/80165014/236459680-a1ac2775-9f12-4c0f-9c2b-4171aa1baa50.png)

<br><br>

## 2. 구체적인 요구사항 목록(진행중)

**플래너** **기능**

•Daily

1.예정된 일정 기록 (일정 제목, 일정 시간 등을 기록)

2.하루 목표 설정 (업무 제목, 업무 시작 시간 및 종료 시간) 

3.하루 목표에 체크 박스 버튼을 추가 -> 업무 완료시 체크하고 해당 업무에 완료 표시가 됨.

4.예정된 일정과 하루 목표 부분에 각각 추가 버튼을 넣어 일정과 업무를 자유롭게 추가할 수 있도록 함.

5.하단에 오늘 하루 업무 진행률을 확인할 수 있도록 함. 

6.하루 목표 옆에 시간 측정 버튼을 추가함 -> 버튼을 터치하면 타이머 화면을 전환되어 필요 시 시간을 측정하며 업무를 진행할 수 있음.

7.업무 완료 시, 업무 시간에 비례하는 경험치가 부여됨. 경험치로 아이템을 구매할 수 있고, 화폐처럼 사용할 수 있음.

<br>

•Monthly

1.현재 달을 표시하고 캘린더를 화면에 보여줌. 

2.캘린더 화면에는 일정이나 업무가 있는 날에는 점을 찍어 표시함. 

3.하단에는 이번 달에 계획한 총 목표 개수와 완료/미완료 목표를 표시함으로써 성취감(혹은 부진)을 느낄 수 있도록 함. 

<br>

**캐릭터 기능**

•캐릭터 방 

1.전체적인 캐릭터 방과 캐릭터를 보여준다. (웹 뷰를 활용하여 언리얼을 띄움)

2.아이템 버튼을 터치하면 화면이 전환된다. -> 현재 보유하고 있는 아이템 목록을 확인할 수 있고, 미리보기 버튼을 통해 착용한 모습을 확인할 수 있으며 착용 버튼을 통해 아이템을 캐릭터에 실제로 착용 시킬 수 있다. 

3.아이템 화면에는 ‘상점으로‘ 버튼이 있다. -> 이 버튼을 통해 상점으로 이동할 수 있고, 아이템의 이미지, 가격 등을 확인 할 수 있다. 미리보기 버튼을 통해 구매 전에 착용 모습을 볼 수 있고, 구매하기 버튼을 통해 아이템을 소유할 수 있다.

4.MyPage 버튼을 터치하면 화면이 전환된다. -> 캐릭터 정보, 누적 경험치 등을 볼 수 있다.

<br>

**친구 기능**

1.메뉴바에 있는 ‘친구‘ 버튼을 누르면 친구 목록을 확인 할 수 있다. 

2.친구의 정보를 볼 수 있고, 친구 방에 방문할 수도 있다. 

3.하단에 ‘+’ 버튼을 통해 친구를 추가할 수 있다. 

<br>

**설정 기능**

1.메뉴바에 있는 ‘설정‘ 버튼을 누르면 설정을 변경하고 라이선스 정보를 확인 할 수 있다. 

<br><br>

## 3. 설계시작(진행중)

### 3-1. 도메인 모델 분석

![image](https://user-images.githubusercontent.com/80165014/236460404-e3151f36-8c8e-4bc3-bda4-9d23d43063a7.png)

<br>

### 3-2. 테이블 설계

![image](https://user-images.githubusercontent.com/80165014/236460476-6fa237d5-067b-431c-970e-a94b6830012b.png)

<br>

### 3-3. 엔티티 설계

![image](https://user-images.githubusercontent.com/80165014/236460598-19b1cef5-e82b-4d2f-a0fa-db4b41e6a1ae.png)

<br>

### 3-4. ERDCloud

[![ERDCloud](https://user-images.githubusercontent.com/80165014/236461896-b89f1ef7-660c-4f3f-8a92-842adb3db44c.png)](https://www.erdcloud.com/d/ZThXeWGTiKuj23yzT "ERDCloud로 이동하기")

<br><br>

# 기능들 로직

## 1. 로그인 처리 로직

**세션 방식을 사용 (물론 전달을 해야해서 쿠키도 함께 사용)**

* 맨 처음에 로그인을 하면 서버에서 세션Id를 담은 쿠키를 클라에 응답으로 준다.
* 클라는 요청시 항상 쿠키에 세션Id가 포함되어 전달하게되고,  
  서버는 전달받은 쿠키 정보로 "세션 저장소"를 조회해서 회원임을 인증한다 => 메모리에 "세션 저장소(톰캣이 관리)" 존재

<br>

**<클라이언트>**

* **클라 상에서 로그인 기록 있으면 "소셜 로그인" 화면 없이 그냥 바로 => 서버로 uid 전송**
  * API 주소는 "로그인" 주소를 준다.
* **클라 상에서 로그인 기록 없으면 "소셜 로그인" 화면 및 로그인 시도 => 이때, 서버로 uid 전송**
  * API 주소는 "회원가입" 주소를 준다.
* **클라 상에서 로그아웃을 요청하는 경우는 쿠키 정보가 있어서 바로 API 호출 및 "소셜 로그인" 화면으로 이동.**
  * 물론, 클라 상의 로그인 기록도 꼭 지워줘야 나중에 "회원가입"으로 잘 넘어감.
  * API 주소는 "로그아웃" 주소를 준다.
* **마지막으로 앱의 종료 이벤트때 "로그아웃 API"  호출 코드를 작성한다. => 사용X**
  * onDestroy같이 앱 종료 이벤트때 웹뷰에서 얻은 쿠키정보를 request에 담아서 로그아웃 API 호출해주기
  * **=> 정정 : 그냥 쿠키 만료 시간을 설정해두겠다.**

<br>

**<서버>**

* **로그인 API => 받은 uid로 회원판단 시도!! ("회원 저장소"에서 확인!!)**
  - **회원 이라면,**
    * `HttpSession` 로 세션Id를 생성해서 "회원 저장소"에서 받은 회원정보(=memberA)와 함께 "세션 저장소"에 기록

    * 세션Id를 응답 쿠키로 전달

  - **회원 아니라면,** 
    - 회원이 아니라고 클라에게 전송 (클라는 위 <클라>파트의 2번 카테고리를 행하면 됨)


* **회원가입 API => 받은 uid로 회원판단 시도!! ("회원 저장소"에서 확인!!)**
  - **첫 가입 회원이면,**
    * uid, 기타정보 등등을 "회원 저장소"에 기록하고, `HttpSession`로 세션Id를 생성해서 회원정보(=memberA)와 함께 "세션 저장소"에 기록

    * 세션Id를 응답 쿠키로 전달

  - **이미 가입한 중복 회원이면,**
    - 이미 회원이라고 클라에게 전송 (클라는 위 <클라>파트의 1번 카테고리를 행하면 됨)


* **로그아웃 API**
  - 쿠키 정보에 세션Id를 활용해서 해당 세션을 "세션 저장소"에서 제거

<br><br>

# Folder Structure

개발 끝무렵에 정리 => 프로젝트 코드, 폴더들 구조 나타내며 간단 설명
